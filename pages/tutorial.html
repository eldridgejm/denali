<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>denali documentation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../resources/bootstrap.css" type="text/css" />
  <link rel="stylesheet" href="../resources/main.css" type="text/css" />
</head>
<body>
<div id="content">

<div id="header">
<a href="../index.html"><img src="../resources/docslogo.png"></a>
</div>

<hr>

<h1 id="tutorial">Tutorial</h1>
<p>This tutorial serves as an in-depth first introduction to denali. Along the way, you will gain an understanding for how to interpret the visualization produced by <em>denali</em>, how to use the graphical interface, and how to use <em>denali</em>'s tools to visualize other sources of data, such as a scalar functions defined on point clouds.</p>
<p>The files we will use in this tutorial are located in the <code>examples/tutorial</code> directory.</p>
<hr />
<p><strong>Table of contents</strong>:</p>
<ul>
<li><a href="#introduction-to-landscape-metaphors">Introduction to landscape metaphors</a>
<ul>
<li><a href="#scalar-trees">Scalar trees</a></li>
<li><a href="#interpreting-landscapes">Interpreting landscapes</a></li>
</ul></li>
<li><a href="#basic-usage">Basic usage</a>
<ul>
<li><a href="#the-input-tree">The input tree</a></li>
<li><a href="#loading-the-tree">Loading the tree</a></li>
<li><a href="#exploring-the-landscape">Exploring the landscape</a></li>
<li><a href="#selecting-a-component">Selecting a component</a></li>
<li><a href="#simplifying-the-visualization">Simplifying the visualization</a></li>
<li><a href="#choosing-a-root">Choosing a root</a></li>
<li><a href="#rebasing-the-landscape">Rebasing the landscape</a></li>
</ul></li>
<li><a href="#specifying-custom-behavior">Specifying custom behavior</a>
<ul>
<li><a href="#specifying-a-weight-map">Specifying a weight map</a></li>
<li><a href="#specifying-a-color-map">Specifying a color map</a></li>
<li><a href="#printing-special-information-about-a-selection">Printing special information about a selection</a></li>
</ul></li>
<li><a href="#visualizing-functions-on-point-clouds">Visualizing functions on point clouds</a>
<ul>
<li><a href="#introduction-to-contour-trees">Introduction to contour trees</a></li>
<li><a href="#building-a-neighbor-graph">Building a neighbor graph</a></li>
<li><a href="#computing-the-contour-tree">Computing the contour tree</a></li>
</ul></li>
</ul>
<hr />
<h2 id="introduction-to-landscape-metaphors">Introduction to landscape metaphors</h2>
<p>As described in the <a href="intro.html">introduction</a>, <em>denali</em> is a tool for visualizing data that meets two prerequisites. First, each data point must have an associate scalar value, whether it be a probability, score, cost, etc. Second, it must be possible to extract some tree-like structure from the data. <a href="#visualizing-functions-on-point-clouds">Later</a> in this tutorial, we'll see how to extract tree-like structure from such things as scalar functions defined on point clouds. For now, we'll assume that our data is already in tree-like form.</p>
<h3 id="scalar-trees">Scalar trees</h3>
<p>The fundamental unit of input in <em>denali</em> is the <em>scalar tree</em>. A scalar tree is a tree for which every node has an associated integer ID and scalar value. An example of a (directed) scalar tree is shown below.</p>
<center>
<img style="margin:20pt 20pt" width=400 src="../resources/tree.png">
</center>

<p>Note that while the above tree is directed, in general, input to <em>denali</em> is an undirected scalar graph. A direction is imposed whenever a root node is chosen. This can be done using <em>denali</em>'s interface.</p>
<p>A <strong>node</strong> is a vertex of the scalar tree. It has an integer ID and a scalar value.</p>
<p>A <strong>member</strong> is like a node, but it is contained in the edges of the tree. It also has an integer ID and a scalar value.</p>
<p>In the above image, nodes are contained within the ellipses, and members are printed next to the edges in which they are contained.</p>
<p>Each node and member can be assigned a positive real number as a <strong>weight</strong>. By default, this weight is simply one. Later, we'll see how to specify a weight map.</p>
<p>Each arc of a directed scalar tree may also be referred to as a <strong>component</strong> of the tree. Since each component may have members, we can define the <strong>component weight</strong> to be the sum of all member weights. Since each member by default has unit weight, this usually means that the default component weight is simply the number of members it contains. For example, in the above scalar tree, the 4 → 5 component has weight 1, while the 5 → 7 component has weight zero.</p>
<p>We'll also want to define the notion of a <strong>total weight</strong> on the nodes of the directed tree. If no custom weight map is specified, meaning that each node and member has unit weight, the total weight of a node <em>v</em> is simply the number of nodes and members in the subtree rooted at <em>v</em>, including <em>v</em> itself.</p>
<p>More specifically, the total weight of a node is defined to be the sum of:</p>
<ul>
<li>the total weights of the node's children,</li>
<li>the weight of the node itself,</li>
<li>and the weights of all outgoing arcs.</li>
</ul>
<p>Assuming that the weight of each node and member is one, as it is by default, the total weight of node 3 in the above directed tree is simply one. The total weight of node 10 is 4. To see this, note that each of its two children have unit weight. It has two outgoing arcs, but only one of these arcs has nonzero weight: the one that contains member 6. Node 10 itself has weight 1, bringing the total weight to 4. Lastly, the total weight of the root of the tree, node 4, is 12. This is equal to the total number of nodes and members in the tree as a whole.</p>
<h3 id="interpreting-landscapes">Interpreting landscapes</h3>
<p><em>Denal</em> visualizes scalar trees like those described above as landscape metaphors. To understand a landscape metaphor, let's build one from the simple scalar tree show below:</p>
<center>
<img style="margin:20pt 20pt" width=300 src="../resources/interpret_tree.png">
</center>

<p>The exact scalar values associated with each node aren't important, but note that the tree is laid out so that the scalar values increase from bottom to top. That is, the scalar value associated with node 0, denoted by <em>f(0)</em>, is less than the scalar value associated with node 1. Node 7 has the highest scalar value.</p>
<p>Also note that each edge has zero or more members, denoted by the black dots placed on the lines between nodes. We'll assume that all nodes and members have the default weight of one.</p>
<p>The first step in drawing this tree as a landscape is to pick a root node. Much of the time, the node with the minimum scalar value is the natural choice to be the root node. Let's make node 0 the root of our landscape.</p>
<p>Next, we draw the rectangular treemap representing the tree. The figure below shows what this looks like:</p>
<center>
<img style="margin:20pt 20pt" width=300 src="../resources/interpret_map.png">
</center>

<p>You'll notice that each node in the tree has been mapped to a shape in the treemap. Branch nodes (and the root node) have been mapped to rectangles. Leaf nodes have been mapped to points. In what follows, the 2-d shape to which a node is mapped to is referred to as its <strong>contour</strong>.</p>
<p>The nested relationship of the contours is important. If a contour <em>u</em> contains another contour <em>v</em>, then <em>v</em> is in the subtree rooted at node <em>u</em>. If <em>v</em>'s contour is directly nested within <em>u</em>'s, then <em>v</em> is a child of <em>u</em>. For example, node 0's contour is the outermost contour, which is to be expected because every node in the tree is in the subtree rooted at node 0. Node 1 is the child of node 0, and so its contour is nested directly within node 0's.</p>
<p>A branch node's contour is split into several pieces: one for each of its children. The contour of each child is embedded within its corresponding piece. Consider, for example, branch contour 2. It is split into two pieces: one for node 3, and another for node 4. The region between the boundary of a split piece and the inner nested contour represents an arc. The following figure makes this clear:</p>
<center>
<img style="margin:20pt 20pt" width=450 src="../resources/interpret_correspondence.png">
</center>

<p>Some of the arcs of the tree and their corresponding regions in the map have been colored. Note, for example, the orange region between contour 1 and contour 2. This corresponds to the orange arc in the tree between node 1 and node 2.</p>
<p>Since arcs in the tree correspond to regions in the map, it makes sense to choose the areas of these regions so that they reflect the <strong>component weights</strong> of their corresponding arcs. For example, look at the arcs 2 → 3 and 2 → 4. Arc 2 → 3 has two members, and therefore has component weight 2. Arc 2 → 4, on the other hand, has no members, and so it has weight 0. This is reflected in the treemap: the region corresponding to arc 2 → 3 is larger than the region corresponding to 2 → 4. In general, the area between two contours is a function of the weight of the arc connecting the corresponding nodes in the tree.</p>
<p>Likewise, the area of a contour itself encodes information about the <strong>total weight</strong> of the corresponding node. Notice, for example, that the area of contour 5 is larger than that of contour 2. This implies that the total weight of node 5 is larger than that of node 2, which is in fact the case: node 5 has total weight of 8, while node 2 has total weight 5. In general, the area of contour 5 is greater than the area of contour 2 by a ratio that will be (approximately) 8:5.</p>
<p>The last step in creating the landscape metaphor is to &quot;lift&quot; each contour to a height in the third dimension that corresponds to it's nodes scalar value. This looks like the following:</p>
<center>
<img style="margin:20pt 20pt" width=400 src="../resources/interpret_landscape.png">
</center>

<p>Viewed from above, the landscape metaphor is exactly the treemap described above. From the side, however, the height of points on the landscape convey information about the scalar function defined on the tree. Node 7, for example, has the highest scalar value in our tree, and it is therefore the tallest point in our landscape metaphor.</p>
<p>Next we will see how to use the software to build and visualize a simple tree.</p>
<h2 id="basic-usage">Basic usage</h2>
<h3 id="the-input-tree">The input tree</h3>
<p>The tree we will be visualizing is shown below:</p>
<center>
<img style="margin:20pt 20pt" width=400 src="../resources/tree.png">
</center>

<p>Of course, this tree is simpler than the usual sort of input we'll want to visualize with <em>denali</em>, but it is useful for demonstration purposes.</p>
<p>Each node has a positive integer id and a scalar value. In this case, the values are also positive integers, but in general they can be arbitrary real numbers. We also see that some edges have labels next to them. These represent the edges <em>members</em>: lists of vertices that are hidden within each edge. Each member has an unique id, distinct from the ids of the vertices in the tree, and an associated scalar value.</p>
<p>The undirected version of the above tree is represented in <code>examples/tutorial/tree.tree</code>.</p>
<p>If we look inside the file, this is what we see:</p>
<pre><code>9
11  30
10  53
9   51
8   58
7   39
5   32
4   16
3   66
1   62
11  7
10  3   6   64
10  7
9   10
8   7
5   4   0   25
5   1   2   45
5   7</code></pre>
<p>In brief, the format of the <code>tree.tree</code> file is as follows: the first line states the number of vertices in the tree. The next nine lines define the vertices: the first number is the id, and the second is the scalar value. The two numbers are separated by a tab. The remainder of the lines list the edges in the undirected tree. The first two numbers on each line are the ids of the vertices defining the edge. The trailing pairs of numbers on the line (if there are any) define the edge's members: the first number in the pair is the member's id, the second number is the member's value.</p>
<p>For more detailed information on the <code>.tree</code> format, see the <a href="formats.html#tree">format specification</a>.</p>
<h3 id="loading-the-tree">Loading the tree</h3>
<p>With <em>denali</em> running, click <strong>File→Open Tree</strong> and select the <code>tree.tree</code> file in <code>examples/tutorial</code>. You'll see the following (<em>click to enlarge</em>):</p>
<center>
<a href="../resources/scrot_open.png"> <img class="screenshot" src="../resources/scrot_open.png"> </a>
</center>

<p><em>Denali</em> opens with with a birds-eye view of the landscape. By default, the node in the tree with the minimum scalar value is used as the base of the landscape. We'll see how to change this shortly.</p>
<h3 id="exploring-the-landscape">Exploring the landscape</h3>
<p>To explore the visualization, use the mouse:</p>
<ul>
<li><strong>Hold left mouse</strong>: Click and drag to rotate the landscape</li>
<li><strong>Scroll mouse wheel</strong>: Zoom in and out</li>
<li><strong>Hold mouse wheel</strong>: Translate the landscape</li>
<li><strong>Click right mouse</strong>: Select a component</li>
</ul>
<h3 id="selecting-a-component">Selecting a component</h3>
<p>Right clicking selects a component of the landscape. Each component of the landscape is mapped to an arc of the tree. When a component is selected, general information about the selection is printed in the status box in the lower left of the display.</p>
<p>Click the large blue component at the base of the landscape. The status box prints the following information:</p>
<pre><code>Component Selected: 4 → 5
Parent value: 16
Child value: 32
Persistence: 16
Component weight: 1
Parent total weight: 12
Child total weight: 10</code></pre>
<p>For a refresher on what some of these terms mean, see the above section on <a href="#scalar-trees">scalar trees</a>. In summary:</p>
<ul>
<li><p><strong>Component selected</strong>: The ids of the nodes in the selected component are shown here. When the file was opened, the node with the minimum scalar value was automatically assumed to be the root of the tree. This induces a direction on the edges of the tree. Here, we see that node 4 is the parent of node 5 in the directed tree.</p></li>
<li><p><strong>Parent value</strong>: The scalar value associated with the parent node. Here, this is the scalar value associated with node 4.</p></li>
<li><p><strong>Child value</strong>: The scalar value associated with the child node. Here, this is the scalar value associated with node 5.</p></li>
<li><p><strong>Persistence</strong>: The <em>persistence</em> of the arc is the absolute difference between the parent value and the child value. This is used in simplification, as we'll see shortly.</p></li>
<li><p><strong>Component weight</strong>: The &quot;weight&quot; of a component is the sum of the weights of the members contained within the component. By default, a node or member's weight is simply one. If we look at the tree we used as input, we see that the edge between nodes 4 and 5 had a single member. Therefore, the weight of this component is one. Later, we'll see how to specify a positive real number to the vertices and members in the graph, effectively weighting components of the landscape. Note that edges which have no members have a component weight of zero.</p></li>
<li><p><strong>Parent total weight</strong>: The weight of the parent node, plus the weight of all nodes and members in the subtree rooted at the parent node.</p></li>
<li><p><strong>Child total weight</strong>: The weight of the child node, plus the weight of all nodes and members in the subtree rooted at the child node.</p></li>
</ul>
<h3 id="simplifying-the-visualization">Simplifying the visualization</h3>
<p>The tree we are visualizing now isn't very complicated, but sometimes, especially with noisy data, the tree may have many spurious features. These present as small, spiky features in the landscape, and can be distracting.</p>
<p><em>Denali</em> provides a way of suppressing these small features using <em>simplification by persistence</em>. As described above, <em>persistence</em> is the height of component in the landscape: the absolute difference between the parent's scalar value and the child's. A reasonable assumption is that leafy arcs with small persistence aren't very important, while arcs with high persistence are more likely to be of interested.</p>
<p>Simplification in <em>denali</em> is an operation on an entire subtree. First, we'll simplify the entire tree:</p>
<ol style="list-style-type: decimal">
<li>Right click the base of the landscape to select component 4 → 5.</li>
<li>Adjust the simplification threshold slider to about 10.</li>
<li>Click <strong>Refine Subtree</strong>.</li>
</ol>
<p>Your landscape should look like the following:</p>
<center>
<a href="../resources/scrot_simplify.png"> <img class="screenshot" src="../resources/scrot_simplify.png"> </a>
</center>

<p><em>Denali</em> has iteratively collapsed leafy arcs with persistence less than the threshold. Along the way, new leafy arcs are created. For example, exploring the simplified landscape shows that the arc 7 → 3 now exists in our simplified tree. This arc wasn't present in the original tree, but simplification has connected the two. Note that the arc has a component weight of 3: this is because the arc &quot;contains&quot; nodes 9 and 10, as well as the member 6 which was originally in the arc from 10 → 3. In this way, the total weight of node 7 has remained the same. That is to say: simplification of a subtree preserves the subtree's total weight.</p>
<p>A careful reader will note that node 11 is no longer in the landscape and it wasn't listed as a member of the 7 → 3 arc. In actuality, node 11 is internally represented as a member of node 7 and contributes to its total weight.</p>
<p>Simplifications can be made in series, and they apply only to the subtree of the selected component. For example, suppose we wanted to see the structure of the simplified 7 → 3 component in more detail.</p>
<ol style="list-style-type: decimal">
<li>Right click the 7 → 3 component.</li>
<li>Adjust the simplification slider to about 5.</li>
<li>Click <strong>Refine Subtree</strong>.</li>
</ol>
<p>You'll see the following:</p>
<center>
<a href="../resources/scrot_simplify2.png"> <img class="screenshot" src="../resources/scrot_simplify2.png"> </a>
</center>

<p>The 7 → 3 component was completely expanded, and the subtree was then simplified down using the new threshold of 5. However, other parts of the landscape, which were previously simplified with a threshold of 10, were left untouched.</p>
<p>Lastly, we may wish to start over and view the entire, unsimplified tree. To do this, select the <strong>Expand</strong> button in the simplification pane.</p>
<h3 id="choosing-a-root">Choosing a root</h3>
<p>When a new landscape is opened in <em>denali</em> the node with the minimum scalar value is used as the base of the landscape. Depending on what the tree represents, however, it may be useful to select a different node as the root.</p>
<p>To select a root, click the <strong>Choose Root</strong> button in the <em>Root Selection</em> pane. To use the maximum node as the root, select the <strong>Maximum node</strong> option. Any vertex in the tree may be used as the root. For example, to set node 7 to be the root, click the radio button next to <strong>Other</strong> and insert 7 in the box, then click <strong>Ok</strong>.</p>
<p>As you see, not all root selections lead to interesting or aesthetically-pleasing visualizations. More often than not, the maximum or minimum nodes are the best choices.</p>
<p>Before we continue, set the root of the landscape to be the minimum node.</p>
<h3 id="rebasing-the-landscape">Rebasing the landscape</h3>
<p>Suppose we are interested in a particular subtree or section of the landscape. We can visualize this section alone by <em>rebasing</em> the tree.</p>
<p>For example, suppose we are only interested in the subtree rooted at node 7, and we'd like to get rid of the rest of the landscape:</p>
<ol style="list-style-type: decimal">
<li>Right click to select the 5 → 7 component. In the context of rebasing, this is equivalent to selecting the 7 node.</li>
<li>Click the <strong>Rebase</strong> button in the <em>Root Selection</em> pane.</li>
</ol>
<p>The rebased landscape now appears in the visualization window. To return to visualizing the full landscape, you'll need to open the tree again by selecting <strong>File → Open Tree</strong>. Before proceeding with the tutorial, make sure that you've done so.</p>
<h2 id="specifying-custom-behavior">Specifying Custom Behavior</h2>
<h3 id="specifying-a-weight-map">Specifying a weight map</h3>
<p><strong>Important</strong>: Before continuing, make sure that the full tree is being visualized by selecting <strong>File → Open Tree</strong> and choosing <code>examples/tutorial/tree.tree</code>.</p>
<p>Each vertex and member in the scalar tree has an associated weight. By default, this weight is simply one. If we'd like to draw attention to a part of the landscape, or represent a second scalar function using the volume of the landscape components, we can specify a mapping from vertex or member id to a positive scalar value.</p>
<p>In this example, we'll re-weight node 8 to have weight 40, and member 0 to have weight 20. If you open the file <code>examples/tutorial/tree.weights</code>, this is what you'll see:</p>
<pre><code>0   20
8   40</code></pre>
<p>These two lines specify the weights for the node and member. Note that not every node or member in the tree appears in the file: a partial mapping is sufficient. Any node or member not listed in the mapping is assumed to have unit weight. For more information on the weight map file format, see the <a href="formats.html#weights">specification</a>.</p>
<p>Now we will load the weight map:</p>
<ol style="list-style-type: decimal">
<li>Click <strong>File → Load Weight Map</strong>.</li>
<li>Select <code>examples/tutorial/tree.weights</code>.</li>
</ol>
<p>This is what you'll see:</p>
<center>
<a href="../resources/scrot_weight.png"> <img class="screenshot" src="../resources/scrot_weight.png"> </a>
</center>

<p>Node 8 is a leaf node at the center of the landscape. If we select component 7 → 8, we see that the child total weight is 40.</p>
<p>Member 0 is a member of the 4 → 5 arc. If we select this component, we see that the component weight is 20, as expected.</p>
<p>You can make changes to the weight map while <em>denali</em> is running, but to recompute the landscape to reflect the changes, you'll need to reload the weight file by following the steps above. If you'd like to go back to visualizing the unweighted landscape, click <strong>File → Clear Weight Map</strong>.</p>
<h3 id="specifying-a-color-map">Specifying a color map</h3>
<p>By default, the color of the landscape is a function of the height (i.e, the scalar value of the vertices). It is possible, however, to choose a custom color function. This is useful, for example, to visualize a second scalar function on top of the landscape.</p>
<p>As noted above, interactively simplifying the tree may create and destroy arcs. Having the user specify a color map by associating each arc to a color is therefore infeasible. Instead, <em>denali</em> has the user map each node and member of the tree to a second scalar value. The user then selects from a set of rules which assign to each arc of the tree a single scalar value. This value is then used to give the arc a color.</p>
<p>Consider, for example, the arc from 4 → 5 in the example tree above. This arc has has a member. In general, an arc may have many members, or none at all. The user will provide a color map associated to the two nodes and member a second scalar value.</p>
<p>There are many ways to reduce these three values associated with the arc to a single value, thereby mapping the arc to a color. For example, we may simply take the mean of the three values. Alternatively, we might want only the parent and child nodes to contribute to the mean. Even simpler, we might just set the value of the child node to be the representative value of the arc.</p>
<p>In each case, we define a set of <em>contributors</em> and a <em>reduction</em>. The set of contributors includes either the parent, child, or both, and optionally the members in the arc. <em>Denali</em> also provides many reductions, such as max, min, mean, and variance, which reduce the set of scalar values associated with the contributors to a single scalar value.</p>
<p>Let's look at a concrete example. First, we must assign each node and member in the tree a second scalar value. Let's just assign each node and member the same value it has in our original tree. This has already been done for you in <code>examples/tutorial/tree.colors</code>. If you open the file, this is what you'll see:</p>
<pre><code>11  30
10  53
9   51
8   58
7   39
5   32
4   16
3   66
1   62
6   64
0   25
2   45</code></pre>
<p>Each node and member in the tree has it's own line. The first number is the id of the node or member, and the second is the value. For more information on the format of <code>.colors</code> files, see the <a href="formats.html#colors">specification</a>.</p>
<p>To use this color map:</p>
<ol style="list-style-type: decimal">
<li>Select <strong>File → Configure Color Map</strong>.</li>
<li>Click <strong>Browse</strong> and select the <code>examples/tutorial/tree.colors</code> color map.</li>
<li>In the <em>Contributors</em> pane, select <strong>Child</strong> and <em>de</em>select <strong>Include members</strong>.</li>
<li>In the <em>Reduction</em> drop-down menu, select <strong>Maximum</strong>.</li>
</ol>
<p>This is what you'll see:</p>
<center>
<a href="../resources/scrot_color.png"> <img class="screenshot" src="../resources/scrot_color.png"> </a>
</center>

<p>What we've done is set the color of each component to be the scalar value assigned to the child node. The color map we've specified isn't very interesting, though: each node and member is mapped to the same scalar value it had in the original tree.</p>
<p>Two of the reductions provided by <em>denali</em> are a bit different: the covariance and correlation reductions. These reductions compute the covariance and correlation between the color scalar function and the original scalar function, useful for comparing the two mappings.</p>
<h3 id="printing-special-information-about-a-selection">Printing special information about a selection</h3>
<p><em>Denali</em> includes a powerful and general callback system. It can be used to invoke external commands whenever a component of the landscape is selected. Communication with the invoked process is done via a simple flat file and STDIN/STDOUT, meaning that callbacks may be written in virtually any programming language without any dependencies on a message-passing library.</p>
<p>There are three flavors of callbacks:</p>
<ul>
<li><p><em>Information</em> callbacks provide a string the <em>Denali</em>, which is then printed in the status box.</p></li>
<li><p><em>Void</em> callbacks function just like information callbacks, but their output is ignored. They can still have side-effects, though, like opening a window containing a plot.</p></li>
<li><p><em>Tree</em> callbacks provide as output a tree in <code>.tree</code> format. This tree replaces the one that was previously being visualized.</p></li>
</ul>
<p>A full treatment of the callback system is outside of the scope of this tutorial — for that, see the <a href="callback.html">callback system section</a>. For now, we'll cover the creation of a simple callback in Python. Whenever a component is selected, the callback will print some information about the selection to the status box. We'll therefore be implementing an <em>info</em> callback.</p>
<p>When <em>denali</em> invokes a callback, it prints useful information about the selected component to a temporary file. The location of this file is provided as the first argument to the callback process. Detailed information about the structure of this &quot;selection file&quot; is in the <a href="callback.html">callback section</a>. For now, we don't need to understand exactly how this file is formatted, just know that it contains the ids of the nodes in the selected components.</p>
<p>Included with <em>denali</em> is the <em>denali.py</em> Python module. Among other things, it contains useful functions for interacting with <em>denali</em> data formats. One such function is <code>denali.io.read_selection</code>. This function takes a file-like object representing a selection file and parses it into a dictionary.</p>
<p>The dictionary contains a &quot;component&quot; key representing the selected component. Its value is a 2x2 numpy array whose first column has the ids of the two nodes at either end of the component, and whose second column has the corresponding scalar values of the node.</p>
<p>This is all the information we'll need to write our simple callback. If you look at the <code>examples/tutorial/callback.py</code> file, you'll see:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> sys
<span class="ch">import</span> denali

<span class="kw">with</span> <span class="dt">open</span>(sys.argv[<span class="dv">1</span>]) <span class="ch">as</span> f:
    selection = denali.io.read_selection(f)
    u,v = selection[<span class="st">&#39;component&#39;</span>][:,<span class="dv">0</span>]
    <span class="kw">print</span> <span class="st">&quot;The selection component was {} --&gt; {}.&quot;</span>.<span class="dt">format</span>(
            <span class="dt">int</span>(u), <span class="dt">int</span>(v))</code></pre>
<p>The callback gets the path of the selection file from its first argument. It then reads the selection and prints a simple message to the screen. The standard output of the callback is captured, however, and redirected to the status box in the <em>denali</em>. Therefore, printing information to <em>denali</em>'s status box is as simple as printing to the screen, no matter what language you choose to use.</p>
<p>Now, let's try testing this callback. First thing is first: you'll need the <em>denali</em> python module in your path. There are several ways of doing this. You can pick your favorite, or simply add the line:</p>
<pre class="sourceCode python"><code class="sourceCode python">sys.path.append(<span class="st">&quot;/path/to/denali/python&quot;</span>)</code></pre>
<p>under <code>import sys</code> in the above script.</p>
<p>Now we'll notify <em>denali</em> to use this script as a callback. Click on <strong>File → Configure Callbacks</strong>. You should see the following:</p>
<center>
<a href="../resources/scrot_callback.png"> <img class="screenshot" src="../resources/scrot_callback.png"> </a>
</center>

<p>There are three sections, one for each type of callback. Since we'll be specifying an info callback, we are interested in the first section. Click the <strong>Browse</strong> button and find the <code>examples/tutorial/callback.py</code> script. This will place the path to the callback script in the text box. Click inside the textbox and add <code>python2</code> in front of this path, so that the whole line reads something like:</p>
<pre><code>python2 path/to/denali/examples/tutorial/callback.py</code></pre>
<p>Note that under Unix you could just as well place <code>#!/usr/bin/env python2</code> or similar at the top of <code>callback.py</code> and made the file executable. Then you could omit <code>python2</code> from the text box.</p>
<p>Below the text box are two options: <strong>Run on selection</strong> and <strong>Supply subtree</strong>. When the <strong>Run on selection</strong> box is marked, the callback will automatically be invoked when a selection is made. When the <strong>Supply subtree</strong> box is checked, the callback will be provided with a list of all of the nodes and members in the subtree induced by the selection. Check the <strong>Supply subtree</strong> box, and click <strong>Ok</strong>.</p>
<p>Now, right click to select a component of the landscape, and in the status box in the lower left corner, you'll see the text: &quot;The selection component was: &quot;, followed by the ids of the nodes in your selection.</p>
<p>After a selection is made, you can manually invoke the callback again by clicking the <strong>Info</strong> button in the <em>Callbacks</em> pane at the lower right of the interface.</p>
<p>Note that we could have done <em>anything</em> in our Python callback, such as plotted relevant data in a new window, download information from the internet, or even spawn a new <em>denali</em> process. And while the included utility functions make parsing the selection information very easy, any other language is also capable of reading and interaction with <em>denali</em> in this way.</p>
<h2 id="visualizing-functions-on-point-clouds">Visualizing Functions on Point Clouds</h2>
<h3 id="introduction-to-contour-trees">Introduction to contour trees</h3>
<p>As we have seen, <em>denali</em>'s input is a scalar tree: an undirected graph whose nodes each have an associated real number. We can use the concept of a <em>contour tree</em> to visualize scalar functions defined on other structures, including point clouds.</p>
<p>Consider a scalar function <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> defined on a subset of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cmathbb%7BR%7D%5Ed" alt="\mathbb{R}^d" title="\mathbb{R}^d" />. We can define the <em>level set</em> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%5E%7B-1%7D%28a%29%20%3D%20%5C%7B%20x%20%7C%20f%28x%29%20%3D%20a%20%5C%7D" alt="f^{-1}(a) = \{ x | f(x) = a \}" title="f^{-1}(a) = \{ x | f(x) = a \}" />. For any given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" />, the level set of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> may have several connected components. Intuitively, as we increase or decrease <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" />, these level sets may appear, disappear, merge, or split. This creates a tree, called the <em>contour tree</em>.</p>
<p>Informally speaking, the contour tree captures the &quot;skeleton&quot; of the scalar function. Nodes in the contour tree correspond to critical points of the function. The scalar value of a node in the contour tree is equal to the function's value at the corresponding point in the input space.</p>
<p>It is often the case that we have many samples of a scalar function defined on a potentially high-dimensional space, and we'd like to visualize it somehow. For example, we may want to visualize a probability distribution of many variables. In this case, our dataset is a point cloud. To visualize this data, we'll adopt the following strategy:</p>
<ol style="list-style-type: decimal">
<li><p>Build a neighbor graph by connecting each point in the dataset to its <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> nearest neighbors. <em>denali.py</em> provides a function to do this.</p></li>
<li><p>Compute the contour tree using <em>ctree</em>.</p></li>
<li><p>Visualize with <em>denali</em>.</p></li>
</ol>
<h3 id="building-a-neighbor-graph">Building a neighbor graph</h3>
<p>First, we need some data to visualize. Included in <code>examples/tutorial/data.txt</code> are 10000 samples of a probability density in 4 dimensions. If you'd like to see how the data is generated, you can look at <code>examples/tutorial/gendata.py</code>.</p>
<p>The format of the file is as follows: the first four columns specify the location of the sample. The fifth column denotes the (unnormalized) density of the function at that point.</p>
<p>The script contained in <code>examples/tutorial/makenngraph.py</code> reads this file and computes the 10-nearest-neighbor graph. It then outputs this graph in a format that <code>ctree</code> can use. If you were to open it, you'd find:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> numpy <span class="ch">as</span> np
<span class="ch">import</span> denali

data = np.loadtxt(<span class="st">&quot;data.txt&quot;</span>)

<span class="co"># separate the samples from the density</span>
samples = data[:,:<span class="dv">3</span>]
density = data[:,<span class="dv">4</span>]

<span class="co"># find the edges in a 10-nearest-neighbor graph</span>
edges = denali.contour.kneighbors_complex(samples, <span class="dv">10</span>)

<span class="co"># write the vertices and edges to a file</span>
denali.io.write_vertices(<span class="dt">open</span>(<span class="st">&quot;vertices.txt&quot;</span>, <span class="st">&#39;w&#39;</span>), density)
denali.io.write_edges(<span class="dt">open</span>(<span class="st">&quot;edges.txt&quot;</span>, <span class="st">&#39;w&#39;</span>), edges)</code></pre>
<p>Three utility functions included in <em>denali.py</em> are used here:</p>
<ul>
<li><p><code>kneighbors_complex</code> takes an array of points and the number of neighbors and builds a <em>k</em>nn graph, returning the edges as a list.</p></li>
<li><p><code>write_vertices</code> takes an open file-like object and an array of vertex values and writes the values to the file.</p></li>
<li><p><code>write_edges</code> takes an open file-like object and a list of edge pairs, such as those returned by <code>kneighbors_complex</code>, and writes them to the file.</p></li>
</ul>
<p>For more information on these functions, see the <a href="../pydoc/_build/html/index.html">python documentation</a>.</p>
<p>Running the above script will output two files: <code>vertices.txt</code> and <code>edges.txt</code>. We've included them in <code>examples/tutorial</code>, so you don't have to run the script above to proceed to the next step.</p>
<h3 id="computing-the-contour-tree">Computing the contour tree</h3>
<p><em>ctree</em> is a command-line tool for computing contour trees. It should have been installed alongside <em>denali</em>.</p>
<p><em>ctree</em> has three required arguments:</p>
<pre><code>ctree &lt;vertex value file&gt; &lt;edge file&gt; &lt;tree file&gt; </code></pre>
<p>The <em>vertex file</em> and <em>edge file</em> are the files we just created in the last step. The <em>tree file</em> will be overwritten by <em>ctree</em>: it's where the output will be placed.</p>
<p>In a terminal, navigate to the <code>examples/tutorial</code> directory and type</p>
<pre><code>ctree vertices.txt edges.txt tutorial.tree</code></pre>
<p>Now, start <em>denali</em> and load the <code>tutorial.tree</code> file. You should see a large peak with several other, smaller peaks surrounding it. If so, you've successfully visualized a scalar function defined on a point cloud.</p>
<p>For more information on how to use <em>ctree</em>, see the <a href="ctree.html">ctree documentation</a>.</p>
</div>
</body>
</html>
